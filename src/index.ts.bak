import { app, BrowserWindow, ipcMain, screen, globalShortcut } from 'electron';
import * as path from 'path';
import { clipboardService } from './services/clipboard';
import { dictionaryService } from './services/dictionary';
import { wikipediaService } from './services/wikipedia';
import { searchService } from './services/search';
import { createNativeSelectionService, SelectionEvent } from './services/native-selection';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Check administrator privileges for UIAutomation
function checkAdminPrivileges(): boolean {
  try {
    const { execSync } = require('child_process');
    execSync('net session', { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

// Global variables
let mainWindow: BrowserWindow | null = null;
let popupWindow: BrowserWindow | null = null;
let isMonitoring = false;
let lastSelectedText = '';
let lastSelectionEvent: SelectionEvent | null = null;

// Native selection service
const nativeSelectionService = createNativeSelectionService();

const createMainWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      // Allow text selection and copying in the main window
      webSecurity: true,
    },
    show: false, // Don't show main window by default
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Show window when ready
  mainWindow.once('ready-to-show', () => {
    mainWindow?.show();
  });

  // Handle window close - quit the app
  mainWindow.on('closed', () => {
    console.log('[DEBUG] Main window closed, quitting app...');
    // Force quit the entire app
    setTimeout(() => {
      console.log('[DEBUG] Force quitting app...');
      app.exit(0);
    }, 100);
  });

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

const createPopupWindow = (x: number, y: number): void => {
  console.log(`[DEBUG] Creating popup window`);
  
  // Close existing popup if any
  if (popupWindow && !popupWindow.isDestroyed()) {
    console.log('[DEBUG] Closing existing popup window');
    try {
      popupWindow.close();
    } catch (error) {
      console.warn('[DEBUG] Error closing popup window:', error);
    }
    popupWindow = null;
  }

  // Get screen dimensions
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;

  // Calculate popup position and size
  const popupWidth = 400;
  const popupHeight = 300;
  
  // Ensure popup stays within screen bounds
  const popupX = Math.min(Math.max(x, 0), screenWidth - popupWidth);
  const popupY = Math.min(Math.max(y, 0), screenHeight - popupHeight);

  popupWindow = new BrowserWindow({
    width: popupWidth,
    height: popupHeight,
    x: popupX,
    y: popupY,
    frame: false,
    resizable: true,
    alwaysOnTop: true,
    skipTaskbar: false, // Allow in taskbar for better focus management
    focusable: true,
    show: false,
    transparent: false,
    minWidth: 300,
    minHeight: 200,
    maxWidth: 800,
    maxHeight: 600,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Load the popup HTML using the webpack entry point with a hash
  const popupUrl = MAIN_WINDOW_WEBPACK_ENTRY + '#popup';
  console.log('[DEBUG] Loading popup from:', popupUrl);
  popupWindow.loadURL(popupUrl);

  // Show popup when ready
  popupWindow.once('ready-to-show', () => {
    if (popupWindow) {
      popupWindow.show();
      console.log('[DEBUG] Popup window loaded');
    }
  });

  // Advanced focus and timeout management
  let popupTimeout: NodeJS.Timeout | null = null;
  let isPopupFocused = false;
  let mouseInPopup = false;

  const startPopupTimeout = () => {
    if (popupTimeout) {
      clearTimeout(popupTimeout);
    }
    
    popupTimeout = setTimeout(() => {
      if (popupWindow && !popupWindow.isDestroyed() && !isPopupFocused && !mouseInPopup) {
        console.log('Popup timeout reached, forcing close (not focused)');
        try {
          popupWindow.close();
        } catch (error) {
          console.warn('Error closing popup on timeout:', error);
          popupWindow = null;
        }
      } else if (popupWindow && !popupWindow.isDestroyed()) {
        console.log('Popup timeout postponed - window is focused or mouse inside');
        // Restart timeout for focused windows
        startPopupTimeout();
      }
    }, 30000); // 30 seconds
  };

  const clearPopupTimeout = () => {
    if (popupTimeout) {
      clearTimeout(popupTimeout);
      popupTimeout = null;
    }
  };

  // Focus management
  popupWindow.on('focus', () => {
    console.log('[DEBUG] Popup gained focus - pausing timeout');
    isPopupFocused = true;
    clearPopupTimeout();
  });

  popupWindow.on('blur', () => {
    console.log('[DEBUG] Popup lost focus - restarting timeout');
    isPopupFocused = false;
    if (!mouseInPopup) {
      startPopupTimeout();
    }
  });

  // Mouse enter/leave detection via IPC
  popupWindow.webContents.on('ipc-message', (event, channel, ...args) => {
    if (channel === 'popup-mouse-enter') {
      console.log('[DEBUG] Mouse entered popup - pausing timeout');
      mouseInPopup = true;
      clearPopupTimeout();
    } else if (channel === 'popup-mouse-leave') {
      console.log('[DEBUG] Mouse left popup - checking if should restart timeout');
      mouseInPopup = false;
      if (!isPopupFocused) {
        setTimeout(() => {
          // Double-check after a small delay
          if (!isPopupFocused && !mouseInPopup) {
            startPopupTimeout();
          }
        }, 500);
      }
    } else if (channel === 'popup-clicked') {
      console.log('[DEBUG] Popup clicked - focusing window');
      if (popupWindow && !popupWindow.isDestroyed()) {
        popupWindow.focus();
      }
    }
  });

  // Handle popup close
  popupWindow.on('closed', () => {
    console.log('[DEBUG] Popup window closed');
    clearPopupTimeout();
    popupWindow = null;
  });

  // Handle popup window errors
  popupWindow.on('unresponsive', () => {
    console.warn('[DEBUG] Popup window became unresponsive');
    if (popupWindow && !popupWindow.isDestroyed()) {
      popupWindow.close();
    }
  });

  // Start initial timeout
  startPopupTimeout();
};

const startSelectionMonitoring = (): void => {
  console.log('[DEBUG] ===== STARTING PURE NATIVE SELECTION MONITORING =====');
  
  if (isMonitoring) {
    console.log('[DEBUG] Selection monitoring already active, returning');
    return;
  }

  // Check administrator privileges for UIAutomation
  const isAdmin = checkAdminPrivileges();
  console.log(`[DEBUG] Administrator privileges: ${isAdmin ? 'Yes' : 'No'}`);
  
  if (!isAdmin) {
    console.warn('[WARNING] âš ï¸ NOT RUNNING AS ADMINISTRATOR!');
    console.warn('[WARNING] UIAutomation selection detection requires administrator privileges');
    console.warn('[WARNING] To enable UIAutomation: Run as Administrator or use "npm run start-admin"');
  }

  console.log('[DEBUG] Setting isMonitoring = true');
  isMonitoring = true;

  try {
    // Test native selection service
    console.log('[DEBUG] === NATIVE SELECTION SERVICE TEST ===');
    console.log('[DEBUG] NativeSelectionService object:', typeof nativeSelectionService);
    console.log('[DEBUG] NativeSelectionService methods:', Object.keys(nativeSelectionService));
    console.log('[DEBUG] isSupported:', nativeSelectionService.isSupported());
    
    // Start pure native selection service
    console.log('[DEBUG] === STARTING PURE NATIVE SELECTION ===');
    nativeSelectionService.start().then(() => {
      console.log('[DEBUG] Pure native selection service started successfully');
      
      // Register selection callback with detailed logging
      nativeSelectionService.onSelection((event: SelectionEvent) => {
        console.log(`[UIA-EVENT] ðŸŽ¯ Selection detected: "${event.text}" at (${event.x}, ${event.y})`);
        console.log(`[UIA-EVENT] ðŸ“ Text length: ${event.text.length} characters`);
        console.log(`[UIA-EVENT] â° Timestamp: ${new Date().toISOString()}`);
        console.log(`[UIA-EVENT] ðŸ” Creating popup for UIAutomation selection...`);
        lastSelectionEvent = event; // Store the full event
        createPopupWindow(event.x, event.y);
      });
      
      console.log('[DEBUG] Selection callback registered with detailed logging');
    }).catch((error) => {
      console.error('[ERROR] Failed to start native selection service:', error);
      if (!isAdmin) {
        console.error('[ERROR] This is likely due to insufficient privileges');
        console.error('[ERROR] Try running the app as Administrator');
      }
    });

    // Register global shortcuts
    console.log('[DEBUG] === REGISTERING GLOBAL SHORTCUTS ===');
    registerGlobalShortcuts();
    console.log('[DEBUG] Global shortcuts registered');
    
    console.log('[DEBUG] ===== PURE NATIVE SELECTION MONITORING STARTED SUCCESSFULLY =====');
    console.log('[DEBUG] ðŸŽ¯ UIAutomation is now listening for text selections...');
    console.log('[DEBUG] ðŸ“ Test: Select text in any application and wait 500ms');
    
  } catch (error) {
    console.error('[ERROR] Failed to start selection monitoring:', error);
    console.error('[ERROR] Error stack:', error.stack);
    isMonitoring = false;
  }
};

const stopSelectionMonitoring = (): void => {
  if (!isMonitoring) return;

  try {
    isMonitoring = false;
    console.log('[DEBUG] Selection monitoring stopped');
    
    // Stop pure native selection service
    nativeSelectionService.stop().then(() => {
      console.log('[DEBUG] Pure native selection service stopped');
    }).catch((error) => {
      console.error('[ERROR] Error stopping native selection service:', error);
    });
  } catch (error) {
    console.error('[ERROR] Error stopping selection monitoring:', error);
  }
};

// IPC handlers
ipcMain.handle('start-monitoring', () => {
  startSelectionMonitoring();
  return { success: true };
});

// Manual test for text selection
ipcMain.handle('test-text-selection', () => {
  console.log('[DEBUG] Manual text selection test triggered');
  
  // Reset last selected text to allow testing same text
  lastSelectedText = '';
  console.log('[DEBUG] Reset lastSelectedText to allow testing');
  
  // Simulate a text selection
  const testText = 'hello world';
  console.log(`[DEBUG] Test text: "${testText}"`);
  
  // Get cursor position
  const cursorPosition = screen.getCursorScreenPoint();
  console.log(`[DEBUG] Cursor position: x=${cursorPosition.x}, y=${cursorPosition.y}`);
  
  // Create popup with test text
  createPopupWindow(cursorPosition.x, cursorPosition.y, testText);
  
  return { success: true, text: testText };
});

// Reset selection state for testing
ipcMain.handle('reset-selection-state', () => {
  console.log('[DEBUG] Resetting selection state');
  lastSelectedText = '';
  return { success: true };
});

ipcMain.handle('stop-monitoring', () => {
  stopSelectionMonitoring();
  return { success: true };
});

ipcMain.on('show-popup', (event, { x, y, text }) => {
  createPopupWindow(x, y, text);
});

ipcMain.on('hide-popup', () => {
  if (popupWindow) {
    popupWindow.close();
  }
});

// Test popup creation directly
ipcMain.handle('show-settings-window', () => {
  createSettingsWindow();
});

ipcMain.handle('test-popup', () => {
  console.log('ðŸ” Test popup requested');
  const cursorPosition = screen.getCursorScreenPoint();
  const testText = 'test';
  createPopupWindow(cursorPosition.x, cursorPosition.y, testText);
  console.log('âœ… Test popup created');
  return { success: true };
});

// Clipboard service IPC handlers
ipcMain.handle('clipboard-start-monitoring', () => {
  clipboardService.startMonitoring();
  return { success: true };
});

ipcMain.handle('clipboard-stop-monitoring', () => {
  clipboardService.stopMonitoring();
  return { success: true };
});

ipcMain.handle('clipboard-get-history', () => {
  return clipboardService.getHistory();
});

ipcMain.handle('clipboard-get-recent', (event, count: number = 10) => {
  return clipboardService.getRecentEntries(count);
});

ipcMain.handle('clipboard-search', (event, query: string) => {
  return clipboardService.searchHistory(query);
});

ipcMain.handle('clipboard-copy', (event, text: string) => {
  clipboardService.copyToClipboard(text);
  return { success: true };
});

ipcMain.handle('clipboard-clear', () => {
  clipboardService.clearHistory();
  return { success: true };
});

ipcMain.handle('clipboard-remove-entry', (event, id: string) => {
  return clipboardService.removeEntry(id);
});

ipcMain.handle('clipboard-get-stats', () => {
  return clipboardService.getStats();
});

ipcMain.handle('clipboard-export', () => {
  return clipboardService.exportHistory();
});

ipcMain.handle('clipboard-import', (event, jsonData: string) => {
  return clipboardService.importHistory(jsonData);
});

// Dictionary service IPC handlers
ipcMain.handle('dictionary-lookup', async (event, text: string, targetLanguage: string = 'en', enabledSources?: string[]) => {
  try {
    const result = await dictionaryService.lookup(text, targetLanguage, enabledSources);
    console.log('âœ… Dictionary lookup successful');
    return result;
  } catch (error) {
    console.error('âŒ Dictionary lookup failed:', error);
    throw error;
  }
});

ipcMain.handle('dictionary-set-api-key', (event, apiKey: string) => {
  dictionaryService.setApiKey(apiKey);
  return { success: true };
});

ipcMain.handle('dictionary-set-deepl-api-key', (event, deeplApiKey: string) => {
  dictionaryService.setDeepLApiKey(deeplApiKey);
  return { success: true };
});

ipcMain.handle('dictionary-get-sources', () => {
  return dictionaryService.getAvailableSources();
});

ipcMain.handle('dictionary-get-source-stats', () => {
  return dictionaryService.getSourceStats();
});

ipcMain.handle('dictionary-clear-cache', () => {
  dictionaryService.clearCache();
  return { success: true };
});

ipcMain.handle('dictionary-get-cache-stats', () => {
  return dictionaryService.getCacheStats();
});

ipcMain.handle('dictionary-get-enabled-sources', () => {
  return dictionaryService.getEnabledSources();
});

ipcMain.handle('dictionary-set-source-enabled', (event, sourceName: string, enabled: boolean) => {
  dictionaryService.setSourceEnabled(sourceName, enabled);
  return { success: true };
});

ipcMain.handle('dictionary-get-supported-languages', () => {
  return dictionaryService.getSupportedLanguages();
});

// Wikipedia service IPC handlers
ipcMain.handle('wikipedia-search', async (event, term: string, language: string = 'en', limit: number = 5) => {
  try {
    return await wikipediaService.search(term, language, limit);
  } catch (error) {
    console.error('Wikipedia search failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-get-random', async (event, language: string = 'en') => {
  try {
    return await wikipediaService.getRandomArticle(language);
  } catch (error) {
    console.error('Wikipedia random article failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-get-categories', async (event, pageId: number, language: string = 'en') => {
  try {
    return await wikipediaService.getCategories(pageId, language);
  } catch (error) {
    console.error('Wikipedia categories failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-get-related', async (event, pageId: number, language: string = 'en', limit: number = 5) => {
  try {
    return await wikipediaService.getRelatedArticles(pageId, language, limit);
  } catch (error) {
    console.error('Wikipedia related articles failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-clear-cache', () => {
  wikipediaService.clearCache();
  return { success: true };
});

ipcMain.handle('wikipedia-get-cache-stats', () => {
  return wikipediaService.getCacheStats();
});

// Search service IPC handlers
ipcMain.handle('get-last-selection', () => {
  return lastSelectionEvent;
});

ipcMain.handle('search-get-suggestions', async (event, query: string) => {
  try {
    return await searchService.getSuggestions(query);
  } catch (error) {
    console.error('Search suggestions failed:', error);
    throw error;
  }
});

ipcMain.handle('search-query', async (event, query: string, limit: number = 5) => {
  try {
    return await searchService.search(query, limit);
  } catch (error) {
    console.error('Search query failed:', error);
    throw error;
  }
});

ipcMain.handle('search-get-related', async (event, query: string) => {
  try {
    return await searchService.getRelatedSearches(query);
  } catch (error) {
    console.error('Related searches failed:', error);
    throw error;
  }
});

ipcMain.handle('search-get-trending', async () => {
  try {
    return await searchService.getTrendingSearches();
  } catch (error) {
    console.error('Trending searches failed:', error);
    throw error;
  }
});

ipcMain.handle('search-get-stats', async (event, query: string) => {
  try {
    return await searchService.getSearchStats(query);
  } catch (error) {
    console.error('Search stats failed:', error);
    throw error;
  }
});

ipcMain.handle('search-clear-cache', () => {
  searchService.clearCache();
  return { success: true };
});

ipcMain.handle('search-get-cache-stats', () => {
  return searchService.getCacheStats();
});

// Global shortcut handlers
const registerGlobalShortcuts = (): void => {
  // Register Ctrl+Shift+D to toggle monitoring
  globalShortcut.register('CommandOrControl+Shift+D', () => {
    if (isMonitoring) {
      stopSelectionMonitoring();
    } else {
      startSelectionMonitoring();
    }
  });

  // Register Ctrl+Shift+O to trigger OCR (placeholder for future implementation)
  globalShortcut.register('CommandOrControl+Shift+O', () => {
    console.log('OCR shortcut triggered - not implemented yet');
  });

  // Register Ctrl+Shift+V to show clipboard history
  globalShortcut.register('CommandOrControl+Shift+V', () => {
    if (mainWindow) {
      mainWindow.webContents.send('show-clipboard-history');
    }
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  console.log('[DEBUG] ===== APP READY EVENT =====');
  
  console.log('[DEBUG] Creating main window...');
  createMainWindow();
  
  console.log('[DEBUG] Registering global shortcuts...');
  registerGlobalShortcuts();
  
  console.log('[DEBUG] Starting selection monitoring...');
  startSelectionMonitoring();
  
  console.log('[DEBUG] Starting clipboard monitoring...');
  clipboardService.startMonitoring();
  
  console.log('[DEBUG] ===== APP INITIALIZATION COMPLETE =====');
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  console.log('[DEBUG] All windows closed, cleaning up...');
  
  // Force close any lingering popup windows
  if (popupWindow && !popupWindow.isDestroyed()) {
    console.log('[DEBUG] Force closing popup window...');
    try {
      popupWindow.close();
    } catch (error) {
      console.warn('[DEBUG] Error force closing popup:', error);
    }
    popupWindow = null;
  }
  
  stopSelectionMonitoring();
  clipboardService.stopMonitoring();
  globalShortcut.unregisterAll();
  
  // Force quit on Windows (and Linux too)
  if (process.platform !== 'darwin') {
    console.log('[DEBUG] Force quitting app...');
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
  }
});

// Cleanup on app quit
app.on('will-quit', () => {
  console.log('[DEBUG] App will quit, performing cleanup...');
  stopSelectionMonitoring();
  clipboardService.stopMonitoring();
  globalShortcut.unregisterAll();
});

// Handle app quit
app.on('quit', () => {
  console.log('[DEBUG] App quit event triggered');
});
