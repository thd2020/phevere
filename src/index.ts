import { app, BrowserWindow, ipcMain, screen, globalShortcut, shell } from 'electron';
import * as path from 'path';
import { clipboardService } from './services/clipboard';
import { dictionaryService } from './services/dictionary';
import { wikipediaService } from './services/wikipedia';
import { searchService } from './services/search';
import { createNativeSelectionService, SelectionEvent } from './services/native-selection';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const POPUP_WINDOW_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Check administrator privileges for UIAutomation
function checkAdminPrivileges(): boolean {
  try {
    const { execSync } = require('child_process');
    execSync('net session', { stdio: 'ignore' });
    return true;
  } catch (error) {
    return false;
  }
}

// Global variables
let mainWindow: BrowserWindow | null = null;
let popupWindows: BrowserWindow[] = [];
let settingsWindow: BrowserWindow | null = null;
let isMonitoring = false;
let lastSelectedText = '';
let lastSelectionEvent: SelectionEvent | null = null;
let lastPopupText: string = '';
let lastPopupAt: number = 0;

// Native selection service
const nativeSelectionService = createNativeSelectionService();

// Open custom wiki window in standalone web window (not inside dictionary popup)
ipcMain.on('open-wiki', (_e, term: string) => {
  const url = `https://en.wikipedia.org/wiki/${encodeURIComponent(term)}`;
  createWebWindow(url);
});

const createMainWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    frame: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      // Allow text selection and copying in the main window
      webSecurity: true,
    },
    show: false, // Don't show main window by default
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Show window when ready
  mainWindow.once('ready-to-show', () => {
    mainWindow?.show();
  });

  // REMOVED: This is dangerous and bypasses proper cleanup.
  // The 'window-all-closed' event handles this correctly.
  // mainWindow.on('closed', () => {
  //   console.log('[DEBUG] Main window closed, quitting app...');
  //   setTimeout(() => {
  //     console.log('[DEBUG] Force quitting app...');
  //     app.exit(0);
  //   }, 100);
  // });

  
};

const createPopupWindow = (x: number, y: number): void => {
  console.log(`[DEBUG] Creating popup window at position (${x}, ${y})`);
  console.log('[MAIN-POPUP] entry constant =', POPUP_WINDOW_WEBPACK_ENTRY);

  // Get screen dimensions and scale
  const primaryDisplay = screen.getPrimaryDisplay();
  const { width: screenWidth, height: screenHeight } = primaryDisplay.workAreaSize;
  const scaleFactor = primaryDisplay.scaleFactor || 1;
  console.log(`[DEBUG] Screen dimensions: ${screenWidth}x${screenHeight}, scaleFactor=${scaleFactor}`);

                // Calculate popup position and size - razor-slim toolbar initially
              const popupWidth = 360;
              const popupHeight = 48; // slightly taller so toolbar is fully visible
  
                // Position popup near the selected text, but ensure it stays within screen bounds
              // Convert native (physical px) coordinates to Electron's DIP coordinates
              let popupX = Math.round(x / scaleFactor);
              let popupY = Math.round(y / scaleFactor);

              // Guard against invalid coordinates from UIA; fallback to cursor point
              if (popupX < 0 || popupX > screenWidth || popupY < 0 || popupY > screenHeight) {
                const cur = screen.getCursorScreenPoint();
                popupX = cur.x;
                popupY = cur.y;
              }
              
              // Adjust position to show popup near the text, not under the cursor
              // Place popup slightly to the right and below the selection to avoid covering text
              const offsetX = 18; // move right
              const offsetY = 14; // move down
              popupX = Math.max(10, Math.min(popupX - Math.floor(popupWidth / 2) + offsetX, screenWidth - popupWidth - 10));
              popupY = Math.max(10, Math.min(popupY + offsetY, screenHeight - popupHeight - 10));
              
              // Ensure popup stays within screen bounds
              if (popupX < 10) popupX = 10;
              if (popupY < 10) popupY = 10;
              if (popupX + popupWidth > screenWidth) {
                popupX = screenWidth - popupWidth - 10;
              }
              if (popupY + popupHeight > screenHeight) {
                popupY = screenHeight - popupHeight - 10;
              }
              
              console.log(`[DEBUG] Popup position: (${popupX}, ${popupY}), size: ${popupWidth}x${popupHeight}`);

  console.log(`[DEBUG] Creating BrowserWindow with preload: ${MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY}`);

  // Coalesce duplicate requests for the same text within a short period
  const textForPopup = (lastSelectionEvent && (lastSelectionEvent.text || '').trim()) || lastSelectedText || '';
  const nowTs = Date.now();
  if (textForPopup && lastPopupText === textForPopup && (nowTs - lastPopupAt) < 1500) {
    console.log('[DEBUG] Skipping duplicate popup within 1500ms for same text');
    return;
  }

  // If a popup already exists, reuse it by moving and updating content (but do not resize here)
  const existing = popupWindows.find(win => win && !win.isDestroyed());
  if (existing) {
    try {
      // Only move; size will be managed by renderer's one-time request
      const [currW, currH] = existing.getSize();
      existing.setBounds({ x: popupX, y: popupY, width: currW, height: currH }, false);
      existing.show();
      try { existing.focus(); } catch {}
      if (textForPopup) existing.webContents.send('popup-text', textForPopup);
      lastPopupText = textForPopup;
      lastPopupAt = nowTs;
      console.log('[DEBUG] Reused existing popup window (moved/updated)');
      return;
    } catch (e) {
      console.warn('[DEBUG] Failed to reuse existing popup, creating a new one...', e);
    }
  }

                const newPopupWindow = new BrowserWindow({
                width: popupWidth,
                height: popupHeight,
                x: popupX,
                y: popupY,
                frame: false,
                resizable: true,
                alwaysOnTop: true,
                skipTaskbar: false, // Allow in taskbar for better focus management
                focusable: true,
                show: false,
                transparent: false,
                minWidth: 320,
                minHeight: 36, // Minimum height for slim toolbar
                maxWidth: 1200,
                maxHeight: 900,
                movable: true, // Make window draggable
                webPreferences: {
                  preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
                  nodeIntegration: false,
                  contextIsolation: true,
                },
              });
  console.log(`[DEBUG] BrowserWindow created successfully`);

  // Close on blur to match intended UX
  newPopupWindow.on('blur', () => {
    // Do not close immediately on blur; allow quick reselection without flicker
    setTimeout(() => {
      try {
        const focused = BrowserWindow.getFocusedWindow();
        console.log('[MAIN-POPUP] blur->close check focusedIsPopup:', focused === newPopupWindow);
        if (!newPopupWindow.isDestroyed() && !newPopupWindow.isFocused()) {
          console.log('[MAIN-POPUP] closing on blur (not focused)');
          newPopupWindow.close();
        }
      } catch (e) {
        console.warn('[MAIN-POPUP] blur close check failed:', e);
      }
    }, 250);
  });
// (moved) wiki handler registered at top-level below

  // Add error handling for load failures
  newPopupWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL) => {
    console.error(`[DEBUG] Failed to load popup: ${errorCode} - ${errorDescription} for URL: ${validatedURL}`);
  });

  // FIXED: Load the correct HTML file for the new popup using webpack entry point
  console.log('[MAIN-POPUP] webpack entry:', POPUP_WINDOW_WEBPACK_ENTRY);
  console.log('[MAIN-POPUP] load start');
  // Load the dedicated popup bundle (popup-new.html) without #popup so its own DOM is used
  const popupUrl = POPUP_WINDOW_WEBPACK_ENTRY;
  newPopupWindow.loadURL(popupUrl).then(() => {
    console.log('[MAIN-POPUP] loadURL done');
  }).catch((error) => {
    console.error('[MAIN-POPUP] loadURL failed:', error);
  });

  // After the popup finishes loading, send the selected text to the renderer
  newPopupWindow.webContents.on('did-finish-load', () => {
    try {
      const textToSend = (lastSelectionEvent && lastSelectionEvent.text) || lastSelectedText || '';
      if (textToSend) {
        console.log('[MAIN-POPUP] did-finish-load send popup-text:', textToSend);
        newPopupWindow.webContents.send('popup-text', textToSend);
      } else {
        console.log('[MAIN-POPUP] did-finish-load no text to send');
      }
      lastPopupText = textToSend;
      lastPopupAt = Date.now();
    } catch (e) {
      console.warn('[DEBUG] Failed to send popup-text to renderer:', e);
    }
  });

  // Show popup when ready
  newPopupWindow.once('ready-to-show', () => {
    console.log('[DEBUG] ready-to-show event fired, showing popup');
    newPopupWindow.show();
    try { newPopupWindow.focus(); } catch {}
    console.log('[DEBUG] Popup window shown successfully');
  });

                newPopupWindow.on('closed', () => {
                console.log('[DEBUG] Popup window closed');
                popupWindows = popupWindows.filter(win => win !== newPopupWindow);
                
                // Reset selection state to allow same word to trigger popup again
                console.log('[DEBUG] Resetting selection state for next popup');
                lastSelectionEvent = null; // Reset the main process selection state
                lastSelectedText = ''; // Reset the last selected text
              });

  // Add more event listeners for debugging
  newPopupWindow.on('show', () => {
    console.log('[DEBUG] Popup show event fired');
  });

  newPopupWindow.on('hide', () => {
    console.log('[DEBUG] Popup hide event fired');
  });

  newPopupWindow.on('focus', () => {
    console.log('[DEBUG] Popup focus event fired');
  });

  popupWindows.push(newPopupWindow);
  console.log(`[DEBUG] Popup window added to array. Total popups: ${popupWindows.length}`);
};

const createSettingsWindow = (): void => {
  if (settingsWindow && !settingsWindow.isDestroyed()) {
    settingsWindow.focus();
    return;
  }

  settingsWindow = new BrowserWindow({
    width: 600,
    height: 700,
    parent: mainWindow,
    modal: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
    show: false,
    frame: false,
  });

  const settingsUrl = MAIN_WINDOW_WEBPACK_ENTRY + '#settings';
  settingsWindow.loadURL(settingsUrl);

  settingsWindow.once('ready-to-show', () => {
    settingsWindow.show();
  });

  settingsWindow.on('closed', () => {
    settingsWindow = null;
  });
  // Allow ESC to close via IPC from renderer
  settingsWindow.webContents.on('before-input-event', (_event, input) => {
    if (input.key === 'Escape') {
      settingsWindow?.close();
    }
  });
};

const startSelectionMonitoring = (): void => {
  console.log('[DEBUG] ===== STARTING PURE NATIVE SELECTION MONITORING =====');
  
  if (isMonitoring) {
    console.log('[DEBUG] Selection monitoring already active, returning');
    return;
  }

  // Check administrator privileges for UIAutomation
  const isAdmin = checkAdminPrivileges();
  console.log(`[DEBUG] Administrator privileges: ${isAdmin ? 'Yes' : 'No'}`);
  
  if (!isAdmin) {
    console.warn('[WARNING] ⚠️ NOT RUNNING AS ADMINISTRATOR!');
    console.warn('[WARNING] UIAutomation selection detection requires administrator privileges');
    console.warn('[WARNING] To enable UIAutomation: Run as Administrator or use "npm run start-admin"');
  }

  console.log('[DEBUG] Setting isMonitoring = true');
  isMonitoring = true;

  try {
    // Test native selection service
    console.log('[DEBUG] === NATIVE SELECTION SERVICE TEST ===');
    console.log('[DEBUG] NativeSelectionService object:', typeof nativeSelectionService);
    console.log('[DEBUG] NativeSelectionService methods:', Object.keys(nativeSelectionService));
    console.log('[DEBUG] isSupported:', nativeSelectionService.isSupported());
    
    // Start pure native selection service
    console.log('[DEBUG] === STARTING PURE NATIVE SELECTION ===');
    nativeSelectionService.start().then(() => {
      console.log('[DEBUG] Pure native selection service started successfully');
      
      // Register selection callback with detailed logging
      nativeSelectionService.onSelection((event: SelectionEvent) => {
        console.log(`[UIA] select "${event.text}" @(${event.x},${event.y}) len=${event.text.length}`);

        // Guard: ignore when one of our windows has focus to prevent loops
        const focused = BrowserWindow.getFocusedWindow();
        if (focused && (popupWindows.includes(focused) || focused === mainWindow)) {
          console.log('[MAIN] ignore selection: app/popup focused');
          return;
        }
        lastSelectionEvent = event; // Store the full event
        console.log('[MAIN] lastSelectionEvent set', {
          text: event.text,
          x: event.x,
          y: event.y,
          ts: event.timestamp
        });
    // Notify main window to update recent selections list
    try { mainWindow?.webContents.send('selection-changed', event.text); console.log('[MAIN] sent selection-changed'); } catch (e) { console.warn('[MAIN] send selection-changed failed', e);} 
        // Ensure popup shows the exact selected text. Avoid trimming chars.
        createPopupWindow(event.x, event.y);
      });
      
      console.log('[DEBUG] Selection callback registered with detailed logging');
    }).catch((error) => {
      console.error('[ERROR] Failed to start native selection service:', error);
      if (!isAdmin) {
        console.error('[ERROR] This is likely due to insufficient privileges');
        console.error('[ERROR] Try running the app as Administrator');
      }
    });

    // Register global shortcuts
    console.log('[DEBUG] === REGISTERING GLOBAL SHORTCUTS ===');
    registerGlobalShortcuts();
    console.log('[DEBUG] Global shortcuts registered');
    
    console.log('[DEBUG] ===== PURE NATIVE SELECTION MONITORING STARTED SUCCESSFULLY =====');
    console.log('[DEBUG] 🎯 UIAutomation is now listening for text selections...');
    console.log('[DEBUG] 📝 Test: Select text in any application and wait 500ms');
    
  } catch (error) {
    console.error('[ERROR] Failed to start selection monitoring:', error);
    console.error('[ERROR] Error stack:', error.stack);
    isMonitoring = false;
  }
};

const stopSelectionMonitoring = async (): Promise<void> => {
  if (!isMonitoring) return;

  try {
    isMonitoring = false;
    console.log('[DEBUG] Stopping selection monitoring...');
    
    // Stop pure native selection service
    await nativeSelectionService.stop();
    console.log('[DEBUG] Pure native selection service stopped');
  } catch (error) {
    console.error('[ERROR] Error stopping selection monitoring:', error);
  }
};

// IPC handlers
ipcMain.handle('start-monitoring', () => {
  startSelectionMonitoring();
  return { success: true };
});

// Manual test for text selection
ipcMain.handle('test-text-selection', () => {
  console.log('[DEBUG] Manual text selection test triggered');
  
  // Reset last selected text to allow testing same text
  lastSelectedText = '';
  console.log('[DEBUG] Reset lastSelectedText to allow testing');
  
  // Simulate a text selection
  const testText = 'hello world';
  console.log(`[DEBUG] Test text: "${testText}"`);
  
  // Get cursor position
  const cursorPosition = screen.getCursorScreenPoint();
  console.log(`[DEBUG] Cursor position: x=${cursorPosition.x}, y=${cursorPosition.y}`);
  
  // Create popup with test text
  createPopupWindow(cursorPosition.x, cursorPosition.y);
  try { mainWindow?.webContents.send('selection-changed', testText); } catch {}
  
  return { success: true, text: testText };
});

// Reset selection state for testing
ipcMain.handle('reset-selection-state', () => {
  console.log('[DEBUG] Resetting selection state');
  lastSelectedText = '';
  return { success: true };
});

ipcMain.handle('stop-monitoring', () => {
  stopSelectionMonitoring();
  return { success: true };
});

ipcMain.on('show-popup', (event, { x, y, text }) => {
  lastSelectionEvent = { text, x, y, timestamp: Date.now(), source: 'manual' };
  createPopupWindow(x, y);
});

ipcMain.on('hide-popup', () => {
  popupWindows.forEach(win => {
    if (win && !win.isDestroyed()) {
      win.close();
    }
  });
  popupWindows = [];
});

// Test popup creation directly
ipcMain.handle('show-settings-window', () => {
  createSettingsWindow();
});

ipcMain.handle('test-popup', () => {
  console.log('🔍 Test popup requested');
  const cursorPosition = screen.getCursorScreenPoint();
  const testText = 'test';
  createPopupWindow(cursorPosition.x, cursorPosition.y);
  console.log('✅ Test popup created');
  return { success: true };
});

// Clipboard service IPC handlers
ipcMain.handle('clipboard-start-monitoring', () => {
  clipboardService.startMonitoring();
  return { success: true };
});

ipcMain.handle('clipboard-stop-monitoring', () => {
  clipboardService.stopMonitoring();
  return { success: true };
});

ipcMain.handle('clipboard-get-history', () => {
  return clipboardService.getHistory();
});

ipcMain.handle('clipboard-get-recent', (event, count: number = 10) => {
  return clipboardService.getRecentEntries(count);
});

ipcMain.handle('clipboard-search', (event, query: string) => {
  return clipboardService.searchHistory(query);
});

ipcMain.handle('clipboard-copy', (event, text: string) => {
  clipboardService.copyToClipboard(text);
  return { success: true };
});

ipcMain.handle('clipboard-clear', () => {
  clipboardService.clearHistory();
  return { success: true };
});

ipcMain.handle('clipboard-remove-entry', (event, id: string) => {
  return clipboardService.removeEntry(id);
});

ipcMain.handle('clipboard-get-stats', () => {
  return clipboardService.getStats();
});

ipcMain.handle('clipboard-export', () => {
  return clipboardService.exportHistory();
});

ipcMain.handle('clipboard-import', (event, jsonData: string) => {
  return clipboardService.importHistory(jsonData);
});

// Dictionary service IPC handlers
ipcMain.handle('dictionary-lookup', async (event, text: string, targetLanguage: string = 'en', enabledSources?: string[]) => {
  try {
    const result = await dictionaryService.lookup(text, targetLanguage, enabledSources);
    console.log('✅ Dictionary lookup successful');
    return result;
  } catch (error) {
    console.error('❌ Dictionary lookup failed:', error);
    throw error;
  }
});

ipcMain.handle('dictionary-set-api-key', (event, apiKey: string) => {
  dictionaryService.setApiKey(apiKey);
  return { success: true };
});

ipcMain.handle('dictionary-set-deepl-api-key', (event, deeplApiKey: string) => {
  dictionaryService.setDeepLApiKey(deeplApiKey);
  return { success: true };
});

// Premium dictionary credential handlers
ipcMain.handle('dictionary-set-oxford-credentials', (_event, appId: string, appKey: string) => {
  dictionaryService.setOxfordCredentials(appId, appKey);
  return { success: true };
});

ipcMain.handle('dictionary-set-youdao-credentials', (_event, appKey: string, appSecret: string) => {
  dictionaryService.setYoudaoCredentials(appKey, appSecret);
  return { success: true };
});

ipcMain.handle('dictionary-set-wordsapi-credentials', (_event, rapidApiKey: string, rapidApiHost?: string) => {
  dictionaryService.setWordsApiCredentials(rapidApiKey, rapidApiHost);
  return { success: true };
});

ipcMain.handle('dictionary-set-collins-credentials', (_event, rapidApiKey: string, rapidApiHost: string) => {
  dictionaryService.setCollinsApiCredentials(rapidApiKey, rapidApiHost);
  return { success: true };
});

ipcMain.handle('dictionary-load-cc-cedict', async (_event, url: string) => {
  const ok = await dictionaryService.loadCcCedictFromUrl(url);
  return { success: ok };
});

ipcMain.handle('dictionary-get-sources', () => {
  return dictionaryService.getAvailableSources();
});

ipcMain.handle('dictionary-get-source-stats', () => {
  return dictionaryService.getSourceStats();
});

ipcMain.handle('dictionary-clear-cache', () => {
  dictionaryService.clearCache();
  return { success: true };
});

ipcMain.handle('dictionary-get-cache-stats', () => {
  return dictionaryService.getCacheStats();
});

// Provide a cache-first recall for history lookups
ipcMain.handle('dictionary-recall', async (_event, text: string, targetLanguage: string = 'en') => {
  try {
    // First try cache
    const key = `${(text || '').toLowerCase()}_${targetLanguage}`;
    const stats = dictionaryService.getCacheStats();
    if (stats.entries.includes(key)) {
      // reuse existing regular lookup, which will return cache immediately
      return await dictionaryService.lookup(text, targetLanguage);
    }
    // If not cached, do a normal lookup (it will cache)
    return await dictionaryService.lookup(text, targetLanguage);
  } catch (e) {
    console.error('[DEBUG] recall failed:', e);
    throw e;
  }
});

ipcMain.handle('dictionary-get-enabled-sources', () => {
  const list = dictionaryService.getEnabledSources();
  console.log('[DBG] IPC getEnabledSources ->', list);
  return list;
});

ipcMain.handle('dictionary-set-source-enabled', (event, sourceName: string, enabled: boolean) => {
  console.log('[DBG] IPC setSourceEnabled', { sourceName, enabled });
  dictionaryService.setSourceEnabled(sourceName, enabled);
  return { success: true };
});

ipcMain.handle('dictionary-get-supported-languages', () => {
  return dictionaryService.getSupportedLanguages();
});

// Wikipedia service IPC handlers
ipcMain.handle('wikipedia-search', async (event, term: string, language: string = 'en', limit: number = 5) => {
  try {
    return await wikipediaService.search(term, language, limit);
  } catch (error) {
    console.error('Wikipedia search failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-get-random', async (event, language: string = 'en') => {
  try {
    return await wikipediaService.getRandomArticle(language);
  } catch (error) {
    console.error('Wikipedia random article failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-get-categories', async (event, pageId: number, language: string = 'en') => {
  try {
    return await wikipediaService.getCategories(pageId, language);
  } catch (error) {
    console.error('Wikipedia categories failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-get-related', async (event, pageId: number, language: string = 'en', limit: number = 5) => {
  try {
    return await wikipediaService.getRelatedArticles(pageId, language, limit);
  } catch (error) {
    console.error('Wikipedia related articles failed:', error);
    throw error;
  }
});

ipcMain.handle('wikipedia-clear-cache', () => {
  wikipediaService.clearCache();
  return { success: true };
});

ipcMain.handle('wikipedia-get-cache-stats', () => {
  return wikipediaService.getCacheStats();
});

// Search service IPC handlers
ipcMain.handle('get-last-selection', () => {
  return lastSelectionEvent;
});

ipcMain.handle('search-get-suggestions', async (event, query: string) => {
  try {
    return await searchService.getSuggestions(query);
  } catch (error) {
    console.error('Search suggestions failed:', error);
    throw error;
  }
});

ipcMain.handle('search-query', async (event, query: string, limit: number = 5) => {
  try {
    return await searchService.search(query, limit);
  } catch (error) {
    console.error('Search query failed:', error);
    throw error;
  }
});

ipcMain.handle('search-get-related', async (event, query: string) => {
  try {
    return await searchService.getRelatedSearches(query);
  } catch (error) {
    console.error('Related searches failed:', error);
    throw error;
  }
});

ipcMain.handle('search-get-trending', async () => {
  try {
    return await searchService.getTrendingSearches();
  } catch (error) {
    console.error('Trending searches failed:', error);
    throw error;
  }
});

ipcMain.handle('search-get-stats', async (event, query: string) => {
  try {
    return await searchService.getSearchStats(query);
  } catch (error) {
    console.error('Search stats failed:', error);
    throw error;
  }
});

ipcMain.handle('search-clear-cache', () => {
  searchService.clearCache();
  return { success: true };
});

ipcMain.handle('search-get-cache-stats', () => {
  return searchService.getCacheStats();
});

// Global shortcut handlers
const registerGlobalShortcuts = (): void => {
  // Register Ctrl+Shift+D to toggle monitoring
  globalShortcut.register('CommandOrControl+Shift+D', () => {
    if (isMonitoring) {
      stopSelectionMonitoring();
    } else {
      startSelectionMonitoring();
    }
  });

  // Register Ctrl+Shift+O to trigger OCR (placeholder for future implementation)
  globalShortcut.register('CommandOrControl+Shift+O', () => {
    console.log('OCR shortcut triggered - not implemented yet');
  });

  // Register Ctrl+Shift+V to show clipboard history
  globalShortcut.register('CommandOrControl+Shift+V', () => {
    if (mainWindow) {
      mainWindow.webContents.send('show-clipboard-history');
    }
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  console.log('[DEBUG] ===== APP READY EVENT =====');
  
  console.log('[DEBUG] Creating main window...');
  createMainWindow();
  
  console.log('[DEBUG] Registering global shortcuts...');
  registerGlobalShortcuts();
  
  console.log('[DEBUG] Starting selection monitoring...');
  startSelectionMonitoring();
  
  console.log('[DEBUG] Starting clipboard monitoring...');
  clipboardService.startMonitoring();
  
  console.log('[DEBUG] ===== APP INITIALIZATION COMPLETE =====');
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  console.log('[DEBUG] All windows closed, cleaning up...');
  
  // Force close any lingering popup windows
  popupWindows.forEach(win => {
    if (win && !win.isDestroyed()) {
      win.close();
    }
  });
  popupWindows = [];
  
  stopSelectionMonitoring();
  clipboardService.stopMonitoring();
  globalShortcut.unregisterAll();
  
  // Force quit on Windows (and Linux too)
  if (process.platform !== 'darwin') {
    console.log('[DEBUG] Force quitting app...');
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createMainWindow();
  }
});

// Cleanup on app quit
ipcMain.on('open-external', (event, url) => {
  // Open in external browser
  shell.openExternal(url);
});

// Open URL inside Electron instead of external browser (user-toggle can call this)
ipcMain.on('open-in-app', (_event, url: string) => {
  createWebWindow(url);
});

// Open full dictionary window in-app for a given term
ipcMain.on('open-full-lookup', (_event, term: string) => {
  try {
    createDictionaryWindow(term);
  } catch (e) {
    console.error('[DEBUG] Failed to open full lookup window:', e);
  }
});

// New popup functionality handlers
ipcMain.on('open-clipboard', () => {
  console.log('[DEBUG] Opening clipboard history window');
  // Create a clipboard history window
  const clipboardWindow = new BrowserWindow({
    width: 500,
    height: 600,
    frame: false,
    resizable: true,
    alwaysOnTop: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });
  
  clipboardWindow.loadURL('popup_window.html#clipboard');
  
  clipboardWindow.on('closed', () => {
    console.log('[DEBUG] Clipboard window closed');
  });
});

ipcMain.on('search-wikipedia', (event, term: string) => {
  // Route to in-app web window or later embed panel; keep simple redirect working
  const url = `https://en.wikipedia.org/wiki/${encodeURIComponent(term)}`;
  createWebWindow(url);
});

            ipcMain.on('search-web', (event, term: string) => {
              console.log('[DEBUG] Searching web for:', term);
              const url = `https://www.google.com/search?q=${encodeURIComponent(term)}`;
              createWebWindow(url);
            });

            ipcMain.on('window-resize', (event, { width, height }) => {
              console.log('[MAIN-POPUP] resize request:', width, 'x', height);
              const popupWindow = popupWindows.find(win => win && !win.isDestroyed());
              if (popupWindow) {
                popupWindow.setSize(width, height);
                console.log('[MAIN-POPUP] resized ok');
              } else {
                console.log('[MAIN-POPUP] resize ignored (no active window)');
              }
            });

            ipcMain.on('open-clipboard', () => {
              console.log('[DEBUG] Opening clipboard history window');
              // Create a clipboard history window
              const clipboardWindow = new BrowserWindow({
                width: 500,
                height: 600,
                frame: false,
                resizable: true,
                alwaysOnTop: true,
                webPreferences: {
                  preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
                  nodeIntegration: false,
                  contextIsolation: true,
                },
              });

              clipboardWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + '#clipboard');

              clipboardWindow.on('closed', () => {
                console.log('[DEBUG] Clipboard window closed');
              });
            });

            ipcMain.on('show-settings', () => {
              console.log('[DEBUG] Opening settings window');
              // Create a settings window
              const settingsWindow = new BrowserWindow({
                width: 600,
                height: 500,
                frame: false,
                resizable: true,
                alwaysOnTop: true,
                webPreferences: {
                  preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
                  nodeIntegration: false,
                  contextIsolation: true,
                },
              });

              settingsWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + '#settings');

              settingsWindow.on('closed', () => {
                console.log('[DEBUG] Settings window closed');
              });
            });

            ipcMain.on('open-external', (event, url: string) => {
              console.log('[DEBUG] Opening external URL:', url);
              shell.openExternal(url);
            });

            ipcMain.on('create-new-popup', (event, text: string) => {
              console.log('[DEBUG] Creating new popup for text:', text);
              // Get current mouse position for new popup
              const mousePosition = screen.getCursorScreenPoint();
              // Set last selection so popup can render the word immediately
              lastSelectionEvent = {
                text,
                x: mousePosition.x,
                y: mousePosition.y,
                timestamp: Date.now(),
                source: 'manual',
              };
              // Also broadcast to recent selections UI
              try { mainWindow?.webContents.send('selection-changed', text); } catch {}
              createPopupWindow(mousePosition.x, mousePosition.y);
            });

// Window control handlers
ipcMain.on('window-minimize', () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.minimize();
  }
});

ipcMain.on('window-maximize', () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    if (mainWindow.isMaximized()) {
      mainWindow.unmaximize();
    } else {
      mainWindow.maximize();
    }
  }
});

ipcMain.on('window-close', () => {
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.close();
  }
});

app.on('will-quit', () => {
  console.log('[DEBUG] App will quit, performing cleanup...');
  stopSelectionMonitoring();
  clipboardService.stopMonitoring();
  globalShortcut.unregisterAll();
});

// Handle app quit
app.on('quit', () => {
  console.log('[DEBUG] App quit event triggered');
});

// Function to open a URL in a new window
const openWebWindows: { [url: string]: BrowserWindow | null } = {};

function createWebWindow(url: string): void {
  // Do not de-duplicate by URL; users may search/open different targets rapidly
  // Use a per-URL map only to focus existing if identical URL is requested twice in a row
  if (openWebWindows[url] && !openWebWindows[url].isDestroyed()) {
    openWebWindows[url].focus();
    return;
  }

  let webWindow: BrowserWindow | null = new BrowserWindow({
    width: 1024,
    height: 768,
    show: false,
    parent: mainWindow,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  webWindow.loadURL(url);

  openWebWindows[url] = webWindow;

  webWindow.once('ready-to-show', () => {
    if (webWindow && !webWindow.isDestroyed()) webWindow.show();
  });

  webWindow.on('focus', () => {
    if (webWindow && !webWindow.isDestroyed()) webWindow.moveTop();
  });

  webWindow.on('closed', () => {
    openWebWindows[url] = null;
    webWindow = null;
  });

  // Allow multiple subsequent popups of different URLs without blocking by the map
  setTimeout(() => {
    openWebWindows[url] = null;
  }, 1000);
}


// Create a dedicated dictionary window (expanded) that uses the popup renderer entry
function createDictionaryWindow(term: string): void {
  let dictWindow: BrowserWindow | null = new BrowserWindow({
    width: 820,
    height: 620,
    show: false,
    parent: mainWindow || undefined,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // Seed selection so renderer can render immediately
  lastSelectionEvent = { text: term, x: 0, y: 0, timestamp: Date.now(), source: 'manual' };

  // Use popup renderer but force #popup so it renders dictionary layout expanded
  const expandedUrl = POPUP_WINDOW_WEBPACK_ENTRY + '#popup';
  dictWindow.loadURL(expandedUrl).catch(() => {});

  dictWindow.once('ready-to-show', () => {
    if (dictWindow && !dictWindow.isDestroyed()) dictWindow.show();
  });

  dictWindow.on('closed', () => {
    dictWindow = null;
  });
}
